<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ant Colony Optimization Simulation</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: monospace; 
        }
        .slider-container {
            margin-bottom: 15px;
        }
        .slider-container label {
            display: block;
            margin-bottom: 5px;
        }
        .slider-container input[type="range"] {
            width: 100%;
        }
        .slider-container small {
            color: #aaa;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <!-- Control Panel -->
    <div id="controlPanel" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); color: white; padding: 30px; border-radius: 12px; min-width: 350px; max-height: 90vh; overflow-y: auto;">
        <h2 style="margin-top: 0; margin-bottom: 20px; font-size: 20px;">Ant Colony Optimization</h2>
        <h3 style="margin-bottom: 15px; font-size: 16px;">Hyperparameters</h3>
        
        <div class="slider-container">
            <label>Number of Ants: <span id="numAntsValue">50</span></label>
            <input type="range" id="numAnts" min="10" max="200" value="50">
        </div>
        
        <div class="slider-container">
            <label>Number of Nodes: <span id="numNodesValue">9</span></label>
            <input type="range" id="numNodes" min="5" max="20" value="9">
        </div>
        
        <div class="slider-container">
            <label>Evaporation Rate: <span id="evaporationRateValue">0.10</span></label>
            <input type="range" id="evaporationRate" min="0.01" max="0.5" step="0.01" value="0.1">
            <small>How fast pheromones fade</small>
        </div>
        
        <div class="slider-container">
            <label>Alpha (Pheromone Weight): <span id="alphaValue">2.0</span></label>
            <input type="range" id="alpha" min="0.5" max="5" step="0.1" value="2">
            <small>Importance of pheromone trails</small>
        </div>
        
        <div class="slider-container">
            <label>Beta (Distance Weight): <span id="betaValue">3.0</span></label>
            <input type="range" id="beta" min="0.5" max="5" step="0.1" value="3">
            <small>Preference for shorter paths</small>
        </div>
        
        <div class="slider-container">
            <label>Pheromone Deposit: <span id="depositAmountValue">100</span></label>
            <input type="range" id="depositAmount" min="10" max="500" step="10" value="100">
            <small>Amount of pheromone deposited</small>
        </div>
        
        <div class="slider-container">
            <label>Animation Speed: <span id="speedValue">2.0</span>x</label>
            <input type="range" id="speed" min="0.5" max="5" step="0.1" value="2">
        </div>
        
        <button id="startBtn" style="width: 100%; padding: 12px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 16px; font-family: monospace; font-weight: bold;">
            Generate New Simulation
        </button>
    </div>
    
    <!-- Stats Panel -->
    <div id="statsPanel" style="display: none; position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.8); color: white; padding: 15px 20px; border-radius: 8px; font-size: 14px;">
        <div style="margin-bottom: 8px; font-size: 16px; font-weight: bold;">Statistics</div>
        <div>Ants: <span id="statsAnts">0</span></div>
        <div>Nodes: <span id="statsNodes">0</span></div>
        <div>Iteration: <span id="statsIteration">0</span></div>
        <div>Best Path: <span id="statsBestPath">∞</span></div>
        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #444;">
            <div style="font-size: 12px; color: #aaa;">Hyperparameters:</div>
            <div style="font-size: 11px;">α=<span id="statsAlpha">0</span>, β=<span id="statsBeta">0</span></div>
            <div style="font-size: 11px;">Evap=<span id="statsEvap">0</span></div>
        </div>
        <button id="resetBtn" style="margin-top: 12px; padding: 8px 16px; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer; font-family: monospace; width: 100%;">
            New Simulation
        </button>
    </div>
    
    <!-- Legend -->
    <div id="legend" style="display: none; position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); color: white; padding: 15px 20px; border-radius: 8px; font-size: 12px; max-width: 300px;">
        <div style="font-weight: bold; margin-bottom: 5px;">Legend:</div>
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 3px;">
            <div style="width: 12px; height: 12px; background: #FF5722; border-radius: 50%;"></div>
            <span>Start Node</span>
        </div>
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 3px;">
            <div style="width: 12px; height: 12px; background: #2196F3; border-radius: 50%;"></div>
            <span>End Node (Food)</span>
        </div>
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 3px;">
            <div style="width: 12px; height: 12px; background: #FFEB3B; border-radius: 50%;"></div>
            <span>Ants</span>
        </div>
        <div style="margin-top: 8px;">Edges glow brighter with more pheromones</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Global state
        let scene, camera, renderer, animationId;
        let params = {
            numAnts: 50,
            numNodes: 9,
            evaporationRate: 0.1,
            alpha: 2,
            beta: 3,
            depositAmount: 100,
            speed: 2
        };
        
        // Update slider values
        function setupSliders() {
            const sliders = {
                numAnts: document.getElementById('numAnts'),
                numNodes: document.getElementById('numNodes'),
                evaporationRate: document.getElementById('evaporationRate'),
                alpha: document.getElementById('alpha'),
                beta: document.getElementById('beta'),
                depositAmount: document.getElementById('depositAmount'),
                speed: document.getElementById('speed')
            };
            
            Object.keys(sliders).forEach(key => {
                sliders[key].addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    params[key] = value;
                    
                    // Update display
                    const displayValue = key === 'evaporationRate' || key === 'alpha' || key === 'beta' || key === 'speed' 
                        ? value.toFixed(key === 'evaporationRate' ? 2 : 1)
                        : Math.round(value);
                    document.getElementById(key + 'Value').textContent = displayValue;
                });
            });
        }
        
        function startSimulation() {
            // Hide control panel
            document.getElementById('controlPanel').style.display = 'none';
            document.getElementById('statsPanel').style.display = 'block';
            document.getElementById('legend').style.display = 'block';
            
            // Update stats display
            document.getElementById('statsAnts').textContent = params.numAnts;
            document.getElementById('statsNodes').textContent = params.numNodes;
            document.getElementById('statsAlpha').textContent = params.alpha.toFixed(1);
            document.getElementById('statsBeta').textContent = params.beta.toFixed(1);
            document.getElementById('statsEvap').textContent = params.evaporationRate.toFixed(2);
            
            runSimulation();
        }
        
        function resetSimulation() {
            // Clean up
            if (animationId) cancelAnimationFrame(animationId);
            if (renderer) {
                renderer.dispose();
                const canvas = document.querySelector('canvas');
                if (canvas) canvas.remove();
            }
            
            // Show control panel
            document.getElementById('controlPanel').style.display = 'block';
            document.getElementById('statsPanel').style.display = 'none';
            document.getElementById('legend').style.display = 'none';
            
            // Reset stats
            document.getElementById('statsIteration').textContent = '0';
            document.getElementById('statsBestPath').textContent = '∞';
        }
        
        function runSimulation() {
            const container = document.getElementById('container');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 0);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            // Grid
            const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
            scene.add(gridHelper);
            
            // Generate random nodes
            const nodes = [];
            for (let i = 0; i < params.numNodes; i++) {
                const angle = (i / params.numNodes) * Math.PI * 2;
                const radius = 10 + Math.random() * 10;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                nodes.push(new THREE.Vector3(x, 0, z));
            }
            
            const startNode = 0;
            const endNode = Math.floor(params.numNodes / 2); // Place end node opposite to start
            
            // Draw nodes
            const nodeGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const nodeMaterial = new THREE.MeshBasicMaterial({ color: 0x4CAF50 });
            const startMaterial = new THREE.MeshBasicMaterial({ color: 0xFF5722 });
            const endMaterial = new THREE.MeshBasicMaterial({ color: 0x2196F3 });
            
            nodes.forEach((pos, i) => {
                const mat = i === startNode ? startMaterial : i === endNode ? endMaterial : nodeMaterial;
                const mesh = new THREE.Mesh(nodeGeometry, mat);
                mesh.position.copy(pos);
                scene.add(mesh);
            });
            
            // Generate edges
            const edges = [];
            const edgeSet = new Set();
            
            // Create minimum spanning tree
            const connected = new Set([0]);
            const available = new Set(Array.from({length: params.numNodes}, (_, i) => i).slice(1));
            
            while (available.size > 0) {
                let minDist = Infinity;
                let bestEdge = null;
                
                for (const a of connected) {
                    for (const b of available) {
                        const dist = nodes[a].distanceTo(nodes[b]);
                        if (dist < minDist) {
                            minDist = dist;
                            bestEdge = [a, b];
                        }
                    }
                }
                
                if (bestEdge) {
                    edges.push(bestEdge);
                    edgeSet.add(`${Math.min(bestEdge[0], bestEdge[1])}-${Math.max(bestEdge[0], bestEdge[1])}`);
                    connected.add(bestEdge[1]);
                    available.delete(bestEdge[1]);
                }
            }
            
            // Add random edges
            const extraEdges = Math.floor(params.numNodes * 0.5);
            for (let i = 0; i < extraEdges; i++) {
                const a = Math.floor(Math.random() * params.numNodes);
                const b = Math.floor(Math.random() * params.numNodes);
                if (a !== b) {
                    const key = `${Math.min(a, b)}-${Math.max(a, b)}`;
                    if (!edgeSet.has(key)) {
                        edges.push([a, b]);
                        edgeSet.add(key);
                    }
                }
            }
            
            const edgeLines = [];
            const pheromones = new Array(edges.length).fill(1.0);
            
            edges.forEach((edge) => {
                const points = [nodes[edge[0]], nodes[edge[1]]];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x666666, linewidth: 2 });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                edgeLines.push(line);
            });
            
            // Ant class
            class Ant {
                constructor() {
                    this.reset();
                    const geometry = new THREE.SphereGeometry(0.2, 8, 8);
                    const material = new THREE.MeshBasicMaterial({ color: 0xFFEB3B });
                    this.mesh = new THREE.Mesh(geometry, material);
                    scene.add(this.mesh);
                }
                
                reset() {
                    this.currentNode = startNode;
                    this.path = [startNode];
                    this.visited = new Set([startNode]);
                    this.pathLength = 0;
                    this.progress = 0;
                    this.targetNode = null;
                    this.completed = false;
                }
                
                getDistance(a, b) {
                    return nodes[a].distanceTo(nodes[b]);
                }
                
                selectNextNode() {
                    const current = this.currentNode;
                    const candidates = [];
                    
                    edges.forEach((edge, i) => {
                        let next = -1;
                        if (edge[0] === current && !this.visited.has(edge[1])) next = edge[1];
                        else if (edge[1] === current && !this.visited.has(edge[0])) next = edge[0];
                        
                        if (next !== -1) {
                            const distance = this.getDistance(current, next);
                            const pheromone = pheromones[i];
                            const probability = Math.pow(pheromone, params.alpha) * Math.pow(1 / distance, params.beta);
                            candidates.push({ node: next, prob: probability, edge: i });
                        }
                    });
                    
                    if (candidates.length === 0) return null;
                    
                    const total = candidates.reduce((sum, c) => sum + c.prob, 0);
                    let rand = Math.random() * total;
                    
                    for (const c of candidates) {
                        rand -= c.prob;
                        if (rand <= 0) return c;
                    }
                    
                    return candidates[candidates.length - 1];
                }
                
                update(delta) {
                    if (this.completed) return;
                    
                    if (this.targetNode === null) {
                        const next = this.selectNextNode();
                        if (!next) {
                            this.completed = true;
                            return;
                        }
                        this.targetNode = next.node;
                        this.progress = 0;
                    }
                    
                    this.progress += delta * params.speed;
                    
                    if (this.progress >= 1) {
                        this.currentNode = this.targetNode;
                        this.path.push(this.currentNode);
                        this.visited.add(this.currentNode);
                        this.pathLength += this.getDistance(this.path[this.path.length - 2], this.currentNode);
                        
                        if (this.currentNode === endNode) {
                            this.completed = true;
                        }
                        
                        this.targetNode = null;
                    } else {
                        const start = nodes[this.currentNode];
                        const end = nodes[this.targetNode];
                        this.mesh.position.lerpVectors(start, end, this.progress);
                    }
                }
            }
            
            const ants = [];
            for (let i = 0; i < params.numAnts; i++) {
                ants.push(new Ant());
            }
            
            // ACO parameters
            let iteration = 0;
            let bestPathLength = Infinity;
            let iterationTimer = 0;
            
            // Animation loop
            const clock = new THREE.Clock();
            
            function animate() {
                animationId = requestAnimationFrame(animate);
                
                const delta = clock.getDelta();
                iterationTimer += delta;
                
                // Update ants
                let allCompleted = true;
                ants.forEach(ant => {
                    ant.update(delta);
                    if (!ant.completed) allCompleted = false;
                });
                
                // Reset after iteration
                if (allCompleted && iterationTimer > 1) {
                    iterationTimer = 0;
                    iteration++;
                    
                    // Evaporate pheromones
                    for (let i = 0; i < pheromones.length; i++) {
                        pheromones[i] *= (1 - params.evaporationRate);
                    }
                    
                    // Deposit pheromones
                    ants.forEach(ant => {
                        if (ant.path[ant.path.length - 1] === endNode) {
                            const deposit = params.depositAmount / ant.pathLength;
                            
                            for (let i = 0; i < ant.path.length - 1; i++) {
                                const a = ant.path[i];
                                const b = ant.path[i + 1];
                                const edgeIdx = edges.findIndex(e => 
                                    (e[0] === a && e[1] === b) || (e[0] === b && e[1] === a)
                                );
                                if (edgeIdx !== -1) {
                                    pheromones[edgeIdx] += deposit;
                                }
                            }
                            
                            if (ant.pathLength < bestPathLength) {
                                bestPathLength = ant.pathLength;
                            }
                        }
                    });
                    
                    // Update edge colors
                    const maxPheromone = Math.max(...pheromones);
                    edgeLines.forEach((line, i) => {
                        const intensity = pheromones[i] / maxPheromone;
                        const color = new THREE.Color();
                        color.setHSL(0.6 - intensity * 0.5, 1, 0.3 + intensity * 0.4);
                        line.material.color = color;
                    });
                    
                    // Reset ants
                    ants.forEach(ant => ant.reset());
                    
                    // Update stats
                    document.getElementById('statsIteration').textContent = iteration;
                    document.getElementById('statsBestPath').textContent = bestPathLength.toFixed(2);
                }
                
                renderer.render(scene, camera);
            }
            
            animate();
        }
        
        // Handle resize
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
        
        // Setup event listeners
        setupSliders();
        document.getElementById('startBtn').addEventListener('click', startSimulation);
        document.getElementById('resetBtn').addEventListener('click', resetSimulation);
    </script>
</body>
</html>